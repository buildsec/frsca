// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	corev1 "k8s.io/api/core/v1"
	duckv1 "knative.dev/pkg/apis/duck/v1"
	"knative.dev/pkg/apis/duck/v1beta1"
	"knative.dev/pkg/apis"
)

// EventListener exposes a service to accept HTTP event payloads.
//
// +k8s:openapi-gen=true
#EventListener: {
	metav1.#TypeMeta

	// +optional
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Spec holds the desired state of the EventListener from the client
	// +optional
	spec: #EventListenerSpec @go(Spec)

	// +optional
	status?: #EventListenerStatus @go(Status)
}

// EventListenerSpec defines the desired state of the EventListener, represented
// by a list of Triggers.
#EventListenerSpec: {
	serviceAccountName?: string @go(ServiceAccountName)

	// +listType=atomic
	triggers?: [...#EventListenerTrigger] @go(Triggers,[]EventListenerTrigger)

	// Trigger groups allow for centralized processing of an interceptor chain
	// +listType=atomic
	triggerGroups?: [...#EventListenerTriggerGroup] @go(TriggerGroups,[]EventListenerTriggerGroup)
	namespaceSelector?: #NamespaceSelector           @go(NamespaceSelector)
	labelSelector?:     null | metav1.#LabelSelector @go(LabelSelector,*metav1.LabelSelector)
	resources?:         #Resources                   @go(Resources)
	cloudEventURI?:     string                       @go(CloudEventURI)
}

#Resources: {
	kubernetesResource?: null | #KubernetesResource @go(KubernetesResource,*KubernetesResource)
	customResource?:     null | #CustomResource     @go(CustomResource,*CustomResource)
}

#CustomResource: _

#KubernetesResource: {
	replicas?:    null | int32        @go(Replicas,*int32)
	serviceType?: corev1.#ServiceType @go(ServiceType)
	servicePort?: null | int32        @go(ServicePort,*int32)
	spec?:        duckv1.#WithPodSpec @go(WithPodSpec)
}

// EventListenerTrigger represents a connection between TriggerBinding, Params,
// and TriggerTemplate; TriggerBinding provides extracted values for
// TriggerTemplate to then create resources from. TriggerRef can also be
// provided instead of TriggerBinding, Interceptors and TriggerTemplate
#EventListenerTrigger: {
	// +listType=atomic
	bindings?: [...null | #TriggerSpecBinding] @go(Bindings,[]*TriggerSpecBinding)
	template?:   null | #TriggerSpecTemplate @go(Template,*TriggerSpecTemplate)
	triggerRef?: string                      @go(TriggerRef)

	// +optional
	name?: string @go(Name)

	// +listType=atomic
	interceptors?: [...null | #TriggerInterceptor] @go(Interceptors,[]*TriggerInterceptor)

	// ServiceAccountName optionally associates credentials with each trigger;
	// more granular authorization for
	// who is allowed to utilize the associated pipeline
	// vs. defaulting to whatever permissions are associated
	// with the entire EventListener and associated sink facilitates
	// multi-tenant model based scenarios
	// +optional
	serviceAccountName?: string @go(ServiceAccountName)
}

// EventListenerTriggerGroup defines a group of Triggers that share a common set of interceptors
#EventListenerTriggerGroup: {
	name: string @go(Name)

	// +listType=atomic
	interceptors: [...null | #TriggerInterceptor] @go(Interceptors,[]*TriggerInterceptor)
	triggerSelector: #EventListenerTriggerSelector @go(TriggerSelector)
}

// EventListenerTriggerSelector  defines ways to select a group of triggers using their metadata
#EventListenerTriggerSelector: {
	namespaceSelector?: #NamespaceSelector           @go(NamespaceSelector)
	labelSelector?:     null | metav1.#LabelSelector @go(LabelSelector,*metav1.LabelSelector)
}

// EventInterceptor provides a hook to intercept and pre-process events
#EventInterceptor: #TriggerInterceptor

// SecretRef contains the information required to reference a single secret string
// This is needed because the other secretRef types are not cross-namespace and do not
// actually contain the "SecretName" field, which allows us to access a single secret value.
#SecretRef: {
	secretKey?:  string @go(SecretKey)
	secretName?: string @go(SecretName)
}

// EventListenerBinding refers to a particular TriggerBinding or ClusterTriggerBinding resource.
#EventListenerBinding: #TriggerSpecBinding

// EventListenerTemplate refers to a particular TriggerTemplate resource.
#EventListenerTemplate: #TriggerSpecTemplate

// EventListenerList contains a list of TriggerBinding
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#EventListenerList: {
	metav1.#TypeMeta

	// +optional
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#EventListener] @go(Items,[]EventListener)
}

// EventListenerStatus holds the status of the EventListener
// +k8s:deepcopy-gen=true
#EventListenerStatus: {
	duckv1.#Status

	v1beta1.#AddressStatus

	// Configuration stores configuration for the EventListener service
	configuration: #EventListenerConfig @go(Configuration)
}

// EventListenerConfig stores configuration for resources generated by the
// EventListener
#EventListenerConfig: {
	// GeneratedResourceName is the name given to all resources reconciled by
	// the EventListener
	generatedName: string @go(GeneratedResourceName)
}

// NamespaceSelector is a selector for selecting either all namespaces or a
// list of namespaces.
// +k8s:openapi-gen=true
#NamespaceSelector: {
	// List of namespace names.
	// +listType=atomic
	matchNames?: [...string] @go(MatchNames,[]string)
}

// ServiceExists is the ConditionType set on the EventListener, which
// specifies Service existence.
#ServiceExists: apis.#ConditionType & "Service"

// DeploymentExists is the ConditionType set on the EventListener, which
// specifies Deployment existence.
#DeploymentExists: apis.#ConditionType & "Deployment"

// Check that EventListener may be validated and defaulted.
// TriggerBindingKind defines the type of TriggerBinding used by the EventListener.
#TriggerBindingKind: string // #enumTriggerBindingKind

#enumTriggerBindingKind:
	#NamespacedTriggerBindingKind |
	#ClusterTriggerBindingKind

// NamespacedTriggerBindingKind indicates that triggerbinding type has a namespace scope.
#NamespacedTriggerBindingKind: #TriggerBindingKind & "TriggerBinding"

// ClusterTriggerBindingKind indicates that triggerbinding type has a cluster scope.
#ClusterTriggerBindingKind: #TriggerBindingKind & "ClusterTriggerBinding"
