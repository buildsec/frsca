// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go knative.dev/pkg/apis/duck/v1

package v1

import (
	"knative.dev/pkg/apis"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Addressable provides a generic mechanism for a custom resource
// definition to indicate a destination for message delivery.
//
// Addressable is the schema for the destination information. This is
// typically stored in the object's `status`, as this information may
// be generated by the controller.
#Addressable: {
	// Name is the name of the address.
	// +optional
	name?: null | string    @go(Name,*string)
	url?:  null | apis.#URL @go(URL,*apis.URL)

	// CACerts is the Certification Authority (CA) certificates in PEM format
	// according to https://www.rfc-editor.org/rfc/rfc7468.
	// +optional
	CACerts?: null | string @go(,*string)
}

// AddressableType is a skeleton type wrapping Addressable in the manner we expect
// resource writers defining compatible resources to embed it.  We will
// typically use this type to deserialize Addressable ObjectReferences and
// access the Addressable data.  This is not a real resource.
#AddressableType: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)
	status:    #AddressStatus     @go(Status)
}

// AddressStatus shows how we expect folks to embed Addressable in
// their Status field.
#AddressStatus: {
	// Address is a single Addressable address.
	// If Addresses is present, Address will be ignored by clients.
	// +optional
	address?: null | #Addressable @go(Address,*Addressable)

	// Addresses is a list of addresses for different protocols (HTTP and HTTPS)
	// If Addresses is present, Address must be ignored by clients.
	// +optional
	addresses?: [...#Addressable] @go(Addresses,[]Addressable)
}

// AddressableTypeList is a list of AddressableType resources
#AddressableTypeList: {
	metav1.#TypeMeta
	metadata: metav1.#ListMeta @go(ListMeta)
	items: [...#AddressableType] @go(Items,[]AddressableType)
}
